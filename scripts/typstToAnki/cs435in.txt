*Define vulnerability, threat, and countermeasure*
#pagebreak()
Vulnerability: a weakness in a system that could be exploited to cause harm.

Threat: Set of circumstances that has the potential to cause loss or harm.

Countermeasure: prevents threats from exercising vulnerabilities.

#pagebreak()

*What is the CIA triad?*

#pagebreak()
Confidentiality, Availability, Integrity.

The 3 fundamental aspects of Computer Security.

#pagebreak()

*Give 2 non-CIA security requirements*

#pagebreak()
1. Authentication
2. Non-repudiation

#pagebreak()

*What is the weakest link property?*

#pagebreak()

The overall strength of a security system is the strength of its weakest link.

#pagebreak()

*What is a 2-time pad attack?*

#pagebreak()

If using an XOR operation on a "one-time pad" over 2 different messages. You get the following results

$M_1 xor K = C_1$

$M_2 xor K = C_2$

It is the case that $C_1 xor C_2 = M_1 xor M_2$ which you can then break into based on language redundancies.
#pagebreak()

*What is phishing?*

#pagebreak()

Is when an attacker attempts to "lure" a user to give them private information willingly. 

Usually done via emails or messages asking for personal information.

#pagebreak()

*What is a spoof site, and how can you recognise one?*

#pagebreak()

A spoof site is a fake site that aims to imitate a real site. The goal is to convince users they are on the real site so they provide private personal information.

Usually there are issues on the page such as:
- Don't use SSL
- Inconsistencies
- Grammatical Errors
- Odd URLs

#pagebreak()

*Give 3 ways you can disguise a url?*

#pagebreak()

Typejacking - using similar (but not the same) unicode characters

Using IP Address

Have the real site be a substring in the url.

#pagebreak()

*How can you defend against phishing attacks?*

#pagebreak()

Anti-spam software

Security plugins

Trusted Path (Windows)

Two-factor authentication

#pagebreak()

*What is Smishing?*

#pagebreak()

SMS + phishing


#pagebreak()

*What is CAPTCHA?*

#pagebreak()

Completely Automated Public Turing Test to Tell Computers and Humans Apart.

The goal is to determine wheteher a user is human or not.


#pagebreak()

*Give an example of an attack on CAPTCHA? and what is the CAPTCHA "sweet spot"*

#pagebreak()

An attack on CAPTCHA is when each character always had the same number of pixels. This meant you could encode a character look up table.

Protocol Attack:
 - Man in the middle
 - Outsourcing

A sweet spot is a term to reference the idea difficulty of a Captcha to distinguish humans from computers.


#pagebreak()

*How is reCAPTCHA different to CAPTCHA?*

#pagebreak()

reCAPTCHA gives site admins the flexiblity to decide whether a user is given a CAPTCHA test, where as CAPTCHA is the test itself.

#pagebreak()

*Define:*

* - Cipher*

* - Key*

* - Keyspace*
#pagebreak()

- Cipher: a cryptographic algorithm to perform encryption and decryption
- Key: Used for encryption and decryption
- Keyspace: the range of the key

#pagebreak()

*What are the 4 general types of attack on cryptography schemes?*

#pagebreak()

1. Ciphertext-only
2. Known-plaintext
3. Chosen-plaintext
4. Chosen-ciphertext

#pagebreak()

*Explain confusion and diffusion*

#pagebreak()

- confusion: Obsecures relationship between plaintext and ciphertext
- diffusion: Dissipates redundancy of plaintext by spreading it over ciphertext.

#pagebreak()

*What is a substitution cipher? And what is it's formal definition*

#pagebreak()

A cipher that replaces a refernce of 1 character with another via a mapping.

e.g. Monoalphabetic cipher, polyalphabetic cipher.

Let $P=C=Z_26$. $K$ consists of all possible permutations of the 26 symbols. For each permutation $pi in K$, define

$e_pi (x) = pi(x) mod 26$

$d_pi (y) = pi^(-1) (x) mod 26$

keyspace = 26!
#pagebreak()

*What is the formal definition of a shift cipher?*

#pagebreak()

Let $P = C = K = Z_26$ For $0<=K<=25$ define

$e_k(x) = (x+K) mod 26$

$d_k(y) = (y - K) mod 26$

#pagebreak()

*Why is a shift cipher no good?*

#pagebreak()

Keyspace is only 26. Easy to brute force.

#pagebreak()

*Why is a substitution cipher no good?*

#pagebreak()

Can analyse frequency of characters to gain information between the ciphertext and plain text.

#pagebreak()

*What is a vigenere cipher?*

#pagebreak()

A polyalphabetic cipher based on the idea of combining multiple caeser ciphers.

e.g.

K = 1 2 3 1 2 3 1 2 3

M = B E R E A D Y O K

c = C G U F C G Z Q N

#pagebreak()

*How do you break a vigenere cipher?*

#pagebreak()

1. Find key length
Use Kasiski test.

Search for identical segments and count the number of positions apart. Find common divisors.

Or use index of coincidence.

$I_c (x) = (sum_(i = 0)^25mat(f_i;2))/mat(n;2) = (sum_(i = 0)^25f_i(f_i - 1))/n(n-1) approx sum_(i=0)^25 p_i^2$

In English text this value is usually 0.065. So can iterate through keylengths and separate text into groups until all groups have roughly 0.065 index of coincidence.

2. Find rotation values

Once you have the keylength you can brute force through all possible keys in $26^("key length")$ iterations.

#pagebreak()

*What is a one-time pad?*

#pagebreak()

A "perfect" cryptography scheme where $c_i = k_i xor m_i forall i in 1,2,3...$ 

It is impractical as you would need an infinitely long key.

#pagebreak()

*Bayes' theorem*

#pagebreak()

$p(E_1 | E_2) = (P(E_1)P(E_2 | E_1))/P(E_2)$

#pagebreak()

*Define perfect secrecy*

#pagebreak()

A cryptosystem has perfect secrecy if

$p(m|c) = p(m) forall m in M, c in C$

#pagebreak()

*How can we make OTP practical?*

#pagebreak()

Stream Ciphers.

Basic idea is to use a shorter key to generate a really long key.

#pagebreak()

*Explain Synchronous stream ciphers*

#pagebreak()

Construct the key stream from the key only.

Can use a recurrence algorithm to construct the cipher e.g.:

$k_(i+m) = sum_(j=0)^(m-1)c_j k_(i+j) mod 2$

#pagebreak()

*What's the issue with a synchronous stream cipher?*

#pagebreak()

After a period, the key will repeat.

#pagebreak()

*How is a synchronous stream cipher implemented in hardware?*

#pagebreak()

Using a Lienar Feedback Shift Register (LFSR)

#image("lfsr.png")

#pagebreak()

*Give 3 attacks on stream ciphers*

#pagebreak()

two-time pad attack

No Integrity;
- m = "Transfer £100 to Alice"
- c' = $c xor "Alice" xor "Eve"$
- c = $K xor "Alice"$
- so c' = $K xor "Eve"$

Algorithmic weakness e.g. Content Scramble System for MPEG-2

#pagebreak()

*How was Content Scramble System (CSS) broken?*

#pagebreak()

1. Try all possible 17-bit LFSR to get 20 bytes output
2. Subtract from the first 20 bytes of stream output
3. If consistent with 25-bit LFSR, found the key!

#pagebreak()

*What is Iterated Key Construction in a Block Cipher*

#pagebreak()

Take a key K, and break into n keys via a scheduling algorithm. Use each $k_i$ to encrypt successive blocks of plaintext.

#pagebreak()

*What is a Pseudo Random Function? and what is a Pseudo Random Permutation?*

#pagebreak()

PRF: 

$F: K times X -> Y$

s.t. Exists "efficient" algorithm to evaluate $F(k, x)$

PRP:

$E: K times X -> X$

s.t.
1. Exists "efficient" deterministic algorithm to evaluate $E(k, x)$
2. The function $E(k,.)$ is one-to-one
3. Exists "efficient" inversion algorithm $D(k,.)$

#pagebreak()

*When is a PRP equal to a PRF?*

#pagebreak()

1. X = Y
2. It is invertible

#pagebreak()

*What is a feistel network?*

#pagebreak()

```
For i = 0,1,...,n-1
  L_i_1 = R_i
  R_i_1 = L_i xor F(k_i, R_i)
End
```

Should not swap R and L in last layer so it's easier to invert.

#pagebreak()

*Explain the steps of the F function in a Feistel network?*

#pagebreak()

1. The input (32 bits) is expanded to 48 bits and then XOR'd with the key k.
2. S-boxes
  - 48 bits are split into 8 6-bits, which then go through an S-box to become 8 4-bits
  - #image("s-box.png")
3. P-box
  - (statically) randomly changes the output of the S-boxes.

#pagebreak()

*What to keep in mind when choosing S and P boxes?*

#pagebreak()

Should not be random.

Choose boxes s.t.
- No output bit should be close to a linear function of the input bits.
- S-boxes area 4-to-1 mapping.

#pagebreak()

*Why is double encryption DES not much more secure than DES?*

#pagebreak()

It is susceptible to a Meet in the Middle Attack.

If an attacker knows a pair of ciphertext and plaintext. They can attempt to encrypt the plaintext with all $2^56$ keys and decrypt the ciphertext with all $2^56$ keys. Can then look for a match.

Although the key is 112 bits, it only had 57-bits of entropy.

#pagebreak()

*What is a better alternative to Double DES?*

#pagebreak()

Triple DES - 168 bit key size = 112 bit security.

#pagebreak()

*What is the fundamental difference between AES and DES*

#pagebreak()

DES = Feistel

AES = Substitution-Permutation

#pagebreak()

*Overview of AES*

#pagebreak()
#image("aes-overview.png")
#pagebreak()

*What are the 3 main steps in each round of Substitution-Permutation*

#pagebreak()

1. SubBytes
 - A mapping from input bytes to output bytes
 - input is an element of a finite field $G F(2^8)$
 - Compute the inverse
 - For i = 0, 1, .., 7
  
 $quad quad$do $b_i = (a_i + a_i_4 + a_i_5 + a_i_6 + a_i_y + c_i) mod 2$

2. ShiftRows
  - #image("shift-rows.png")

3. MixColumns
  - Each byte in a column is replaced by 2 times that byte, plus 3 times the next bytem plus the byte that comes next, plus the byte that follows. (obviously, duh).


#pagebreak()

*How does AES key scheduling work?*

#pagebreak()

Expanding the 16 byte key eleven times to 176 bytes (or 44 words).

#image("AES-Key-Scheduling.png")

#pagebreak()

*What are the 5 Modes of operation for AES covered in this module?*

#pagebreak()

- Electronic Code Book
- Cipher Block Chaining
- Cipher Feedback
- Output Feedback
- Counter

#pagebreak()

*Explain Electronic Codebook*

#pagebreak()

Each plaintext block is encrypted independently to generate ciphertext.

Can cause data leakage by identifying patterns between blocks.

#pagebreak()

*Explain Cipher block chaining*

#pagebreak()

The input to each encryption block is:
 - previous blocks ciphertext (or initialisation vector) xor plaintext
 - key

Input is padded so the entire input is a multiple of 16 bytes.

Encryption can then not be parallelised.

Can recover from losing a whole block, but not a single byte.

#pagebreak()

*How does PKCS7 Padding work?*

#pagebreak()

The value of each byte added, is the total number of pad bytes used.

e.g. if 4 bytes are padded, the padding looks like: 04040404

#pagebreak()

*What is the padding oracle attack?*

#pagebreak()

If a server errors if the padding is incorrect, an attacker can use this information to figure out the plaintext.

Can cycle through XORing a random R to the penultimate block and feeding the input to the server. cycle the final byte $r_15$ until the server accepts. We know that $d_15 xor r_15 = 01$, and so $d_15 = 01 xor r_15$. We can then use the IV/original ciphertext to calculate $p_15 = d_15 xor "iv"_15$. 

#pagebreak()

*What is cipher feedback mode?*

#pagebreak()

Similar to CBC, but we encrypt before xoring with plaintext.

#image("cipher-feedback.png")

#pagebreak()

*What is output feedback mode?*

#pagebreak()

Similar to CFB, but we chain the output of encryption, not the XOR of encryption and plaintext.

This is essentially a stream cipher.

#pagebreak()

*What is counter mode?*

#pagebreak()

The input to each encryption is a counter, that was randomly initialised. The output is then XOR'd with the plaintext.

Easily parallelisable, acts as a stream cipher.

#pagebreak()

*What are the security requirements of hash?*

#pagebreak()

1. Pre-image resistance
  - Given H(m), can't find m
2. Second pre-image resistance
  - Given m1, can't find a different message m2 s.t. $H("m1") = H("m2")$
3. Collision resistance
  - Can't find 2 different m1 and m2 s.t. $H("m1")=H("m2")$

#pagebreak()

*What is the Birthday attack on collision resistance?*

#pagebreak()

Assume a hash function with n bits output
1. Select $2^(n/2)$ random  input messages
2. Compute the hash of each input message
3. Look for a collision among the output

#pagebreak()

*What is the implication w.r.t. security on the birthday attack?*

#pagebreak()

For n-bit security, the output of hash must be at least 2n bits long.

#pagebreak()

*What is Merkle-Damgard construction and theorem?*

#pagebreak()

#image("merkle.png")

#pagebreak()

*What are the applications of hash??*

#pagebreak()

- Digital Signature
- Data integrity
- Random Number Generator
- Data Privacy
- Commitment Scheme
- Mining cryptocurrency

#pagebreak()

*What is a MAC?*

#pagebreak()

Message Authentication Code

Goal is to give integrity not confidentiality

#pagebreak()

*What is the Attacker's power and goal in MAC?*

#pagebreak()

- Attacker's power: Chosen Message Attack
  - For m1,m2,..,mq attacker is given ti \<- S(k,mi)
- Attacker's goal: existential forgery
  - Produce some new valid message/tag pair $(m,t) in.not {(m_1,t_1),...,(m_q,t_q)}$

#pagebreak()

*What are the 2 approaches to constructing MAC?*

#pagebreak()

1. Block Cipher
  - Used a fixed IV and run the input through a block cipher

2. Hash Function
  - Secure using H(k\|\|m)

#pagebreak()

*How does HMAC work?*

#pagebreak()

Use secret key at front and back of the message

$"HMAC"(k,m) = H(k xor "opad" || H(k xor "ipad" || m))$

#image("hmac.png")

#pagebreak()

*How does Verification Timing attacks work?*

#pagebreak()

1. Query server with random tag
2. Loop over all possible first bytes and query server. Stop when verification takes a little longer than step 1.
3. Repeat for all tag bytes

#pagebreak()

*How do buffer overflows occur?*

#pagebreak()

When data is written beyond the space allocated for it, e.g. 10th byte in a 6-byte array.

#pagebreak()

*What is a programs memory stack look like?*

#pagebreak()

Text segment:
- Executable code of the program
Data Segment:
- static/global vars
BSS:
- Uninitialized static/global variables
Heap:
- Dynamic memory allocation
Stack:
- Local variables defined inside functions, as well as storing data related to function calls, e.g. return address.

#image("program-stack.png")

#pagebreak()

*What is the layout of the stack?*

#pagebreak()

#image("stack.png")

#pagebreak()
*How does buffer overflow attack work?*

#pagebreak()

#image("buffer-overflow.png")

Task A: Find the offset distance between the base of the buffer and return address.

Task B: Find the address to place the malicious code.

#pagebreak()
*What is hard about buffer overflow attacks, and what 2 techniques can be used to help?*

#pagebreak()

It is not trivial to find where to jump to the malicious code. Could take $2^64$ tried for a 64-bit machine.

Technique 1: Fill NOP

Does nothing so we will continually jump instructions until we reac the malicious code

Technique 2: Ret addr spraying

We can overfill the buffer with return addresses to point towards the malicious code. One of these return addresses will overwrite the original return address of the function.

#pagebreak()
*Countermeasures for buffer overflow attack?*

#pagebreak()

Developer approaches:
- Use safer functions

OS Approaches
- ASLR (Address Space Layout Randomization)

Compiler Approaches
- Stack-Guard

Hardware Approaches
- Non-executable stack

#pagebreak()
*How does ASLR work?*

#pagebreak()

To randomise the start location of the stack every time code is loaded into memory. Makes it hard to predict ebp.

#pagebreak()
*How does a stack guard work?*

#pagebreak()

#image("stack-guard.png")

#pagebreak()

*What is a race condition?*

#pagebreak()

Happens when multiple processes access and manipulate the same data concurrently

The output is dependent on the order of execution.

#pagebreak()

*What does TOCTTOU mean?*

#pagebreak()

Time-Of-Check To Time-Of-Use

e.g. While mediator is checking the access rights for my_file, the user changes the file name to your_File and action to "Delete".

#pagebreak()

*Give an example of a Race Condition attack?*

#pagebreak()

Symbolic link attack. The program to check permissions will inherently have a TOCTTOU window. We have 2 scripts, one to open a file, and the other to change the file to a symbolic link to a secured file. The goal is to have the script change the file to a symbolic link after the check, but before opening the file.

#pagebreak()

*What is Set-UID, and how does it allow users to run privileged programs?*

#pagebreak()

Set-UID is implemented in many unix systems and allows a process to have 2 User IDs
- Real UID (RUID): Identigies the real owner of process
- Effective UID (EUID): Identifies privilege of a process

Set-UID program, RUID $!=$ EUID. RUID is equal to the user's ID, but EUID is set to the owner's ID.

#pagebreak()

*What countermeasures are there for race condition attacks?*

#pagebreak()

Atomic operations: Eliminates the window between check and use.

Sticky Symlink Protection: To prevent creating symbolic links.

Principles of Least Privilege: To prevent the damages after the race is won by the attacker.

#pagebreak()

*How does sticky symlink protection work?*

#pagebreak()

symbolic links inside a sticky world-writable can only be followed when the owner of the symlink matches either the follower or the directory owner.


#pagebreak()

*What are cross-site requests?*

#pagebreak()

When a page from a website sends a HTTP request to a different website.
#image("csrf.png")


#pagebreak()

*What is a cookie?*

#pagebreak()

A packet of information sent from the server to client, and then sent back to the server each time it is accessed by the client.


#pagebreak()

*What are the issues with cross-site requests?*

#pagebreak()

Servers can not distinguish between cross-site and same-site requests, as browser's will attack the relevant cookies. This is called CSRF (Cross-Site Request Forgery).


#pagebreak()

*Countermeasures for CSRF?*

#pagebreak()

Referer Header:
- HTTP header identifying the address of the web page from where the request was generated
- This field reveals part of browsing history, causing privacy concerns. So it isn't used.

Same-Site Cookies
- A special type of cookie that provides an attribute called `SameSite`
- It tells browsers whether a cookie should be attached to a cross-site request or not.

Secret Token
- Server embeds a random secret value inside each web page.
- Secret value is included with the request.
- Pages from a different origin will not be able to access the secret value.


#pagebreak()

*What is XSS?*

#pagebreak()

Cross-Site Scripting.

An attacker injects malicious code to the victim's browser via the target website.

It is an example of a same-site attack.


#pagebreak()

*What are the 2 types of XSS attacks?*

#pagebreak()

Non-persistent
- Attack is not stored on the server. and works by tricking a user to click a malicious link

Persistent
- attacker sends attack data to the server that then gets stored on the server. The website later sends the stored data to other users.


#pagebreak()

*3 damages caused by XSS?*

#pagebreak()

- Web defacing
- Spoofing requests
- Stealing information


#pagebreak()

*Countermeasures to XSS?*

#pagebreak()

- Filter Approach
  - Remove code from user inputs
  - Difficult to implement as there are many ways to embed code.
- Encoding approach
  - Replaces HTML markups with alternate representations
  - e.g. &lt instead of <
- Content Security Policy
  - Force data and code to be separated
  - Don't allow inline approach
  - Only allow the link approach
  - Can allow inline code using Nonce


#pagebreak()

*How does an SQL injection attack work?*

#pagebreak()

Can escape an SQL query by changing your inputs to comment out the rest of the SQL query.

#image("sql-inject.png")

#pagebreak()

*What small alteration needs to be made when performing this attack with CURL?*

#pagebreak()

Need to alter the characters in the URL s.t. they are url-encoded. e.g. replace a space with \%20

#pagebreak()

*How can we delete a database using an sql injection?*

#pagebreak()

Multiple SQL statements.

Does not work with MySQL database, as it has inbuilt protections to not allow multiple SQL statements to execute.


#pagebreak()

*Countermeasures for SQL Injection?*

#pagebreak()

- Prepared statement
  - Allows us to separate code and data
  - Trusted code is sent via a code channel
  - untrusted data is sent via a data channel
  - Database then knows the difference between code and data.

#pagebreak()

*What is promiscuous mode?*

#pagebreak()

Usually, frames that are not destined to a given NIC are discarded.

When operating in promiscuous mode, NIC passes every frame received from the network.

#pagebreak()

*What is monitor mode?*

#pagebreak()

Promiscuous mode available on Wireless Networks.

Wi-Fi card can capture frames on a certain frequency/channel/ Hence, you may miss getting information if you're on a different channel.

#pagebreak()

*How does the NIC receive a packet? What does promiscuous mode do? What is the WiFi equivalent of promiscuous mode, and what are its limitations?*

#pagebreak()

NIC hears all frames on a wire, when it finds a packet addressed to it (by comparing MAC addresses), the frame is copied into a buffer and dispatched to user programs. Frames that aren't destined to the NIC are discarded.

In promiscuous mode, the NIC passes every frame from the network to the kernel.

The WiFi equivalent is monitor mode. Limitations: interference means that the WiFi card can't copy everything, only captures 802.11 frames on the channel the device is listening to so may miss info on other channels.

#pagebreak()

*What does a BSD packet filter (BPF) do? What are the limitations of receiving packets using raw sockets, and what is the solution?*

#pagebreak()

BPF allows a user program to attach a (combination of) filter(s) to a socket, which tells the kernel to discard unwanted packets.

Limitations of raw sockets are: portability issues, lack of optimisation, & difficulty in setting filters. Solution is to use the pcap library, which has a standard API across all platforms & allows programmers to specify rules using human-readable Boolean expressions.

#pagebreak()

*Define packet spoofing. Why are raw sockets preferred for this? What's the procedure to spoof a UDP packet?*

#pagebreak()

Packet spoofing is when some critical information in the packet is forged.

Raw sockets allow us to construct the entire packet (including header fields) before sending it out.

Procedure for UDP:
- Capture UDP packet of interest
- Make a copy
- Replace the UDP data field with a new message & swap the source & destination fields
- Send the spoofed reply

#pagebreak()

*List the pros of using C vs Scapy for constructing a spoofed packet.*

#pagebreak()

Simpler in Scapy but faster in C.

#pagebreak()

*Define endianness.*

#pagebreak()

The order in which a given multi-byte data item is stored in memory.

#pagebreak()

*What's the difference between little endian & big endian? Which is network order? Why is a standardised network order needed?*

#pagebreak()

Little endian puts the small end in memory first; big endian puts the big end in memory first.

Network order is big endian.

Standard required as computers using different byte orders to each other will misunderstand the communications.

#pagebreak()

*Describe the steps in the TCP handshake.*

#pagebreak()

SYN - client sends a packet to the server using a randomly generated number as its sequence number. Server will use a TCB to store information about the connection.

SYN-ACK - server replies using its own randomly generated number as its sequence number.

ACK - client sends an ACK packet to conclude the handshake. The ACK prompts the server to take the TCB out of the queue. SYN-ACK will be resent if the ACK doesn't arrive. Eventually the TCB is discarded once it times out.

#pagebreak()

*Describe a SYN flooding attack. What is a countermeasure?*

#pagebreak()

Continuously send a lot of SYN packets to the server so that queue space is consumed by more and more TCB records. Use random source IP addresses to avoid being blocked by firewalls.

Countermeasure is a SYN cookie - calculate a keyed hash from the information in the packet using a secret key and send to the client, don't store the TCB. When the client sends the ACK, they will respond with cookie+1. An attacker will never receive the cookie.

#pagebreak()

*There's two ways to close a TCP connection. What are they?*

#pagebreak()

TCP FIN
- The #emoji.star.arc civilised #emoji.star.arc way
- A sends a FIN packet to B
- B ACKs, which closes the A-to-B communication
- B repeats to close the entire connections

TCP RST
- One of the parties sends an RST packet to immediately break the connection
- Only meant to be for emergency/error

#pagebreak()

*What's the idea behind a TCP reset attack? Where can you get any info needed?*

#pagebreak()

Break up a TCP connection between A and B by sending an RST packet with the following fields set correctly:
- Source IP address & port
- Destination IP address & port
- A sequence number within the receive window

Use Wireshark to get the necessary window.

#pagebreak()

*How does a TCP Reset attack work on Telnet, SSH and Video-streaming connections? Are there any situations where the attack isn't possible/there could be actions taken?*

#pagebreak()

- Telnet: use an existing netwox tool or write your own program
- SSH: impossible if encryption is done below the transport layer. O/w same as Telnet.
- Video-streaming: use netwox 78 to reset each packet that comes from the user machine. If RST packets are sent continuously to a server, the behaviour is suspicious & punitive actions may be taken against the user.

#pagebreak()

*Describe a TCP session hijacking attack.*

#pagebreak()

Inject data into an established connection. Spoof a TCP packet with these fields set correctly:
- Source IP address & port
- Destination IP address & port
- Sequence number within the receive window

#pagebreak()

*How do you hijack a Telnet connection? What are the consequences of a highjacked TCP connection?*

#pagebreak()

Steps:
- User establishes a telnet connection with the server
- Use Wireshark to sniff the traffic
- Retrieve the destination port, source port & sequence number

Consequences:
- User program freezes
- Retransmission packets between user & server
- Deadlock: client will think the packets are out-of-order and retransmit, server will discard the retransmitted packets as duplicates
- Arbitrary command execution, including getting a reverse shell

#pagebreak()

*How can you defend against TCP attacks? What are these defences effective/ineffective against?*

#pagebreak()

- Make it difficult to spoof packets: not effective against local attacks.
- Encrypt the payload: effective against TCP session hijacking, not effective against SYN flooding and TCP reset attacks.

#pagebreak()

*Define a firewall. What are the requirements?*

#pagebreak()

Part of a computer system/network designed to stop unauthorised traffic flowing from one network to another, allowing the separation of trusted & untrusted components of a network, and the differentiation of networks within a trusted network.

Requirements
- All traffic between trust zones should pass through the firewall
- Only authorised traffic (defined by the security policy) should pass through
- The firewall itself must be immune to penetration, which is achieved by using a hardened system with secured OSs

#pagebreak()

*What are the 3 access policies of a firewall? What are the 3 actions a firewall can take?*

#pagebreak()

Policies
- User control: control access to data based on user role
- Service control: control access by the type of service offered by the host
- Direction control: determine the direction in which a request may be initiated & are allowed to flow through the firewall

Actions
- Accepted: allow the connected network/host through
- Denied: don't allow entry to the other side of the firewall
- Rejected: denied, but you're told through an ICMP packet

#pagebreak()

*What are the 2 types of filtering and 3 types of firewall?*

#pagebreak()

Types of filtering
- Ingress: inspect incoming traffic to safeguard an internal network & prevent external attacks
- Egress filtering: inspect outgoing traffic & prevent users reaching the outside

Packet Filter/Stateless Firewall: control traffic based on information in the packet headers, don't pay attention to whether the packet is part of a stream, don't maintain the packet states.

Stateful Firewall: track the state of the traffic in a connection state table by monitoring all connection interactions until they close.

Application/Proxy Firewall: control input, output & access from/to an application/service by impersonating the intended recipient. Data on the connection is analysed up to the application layer to determine whether the packet should be allowed/rejected.

#pagebreak()

*How do you build a packet filter?*

#pagebreak()

Can be done inside the kernel, using either:
- Netfilter: provides hooks at critical points on the packet traversal path inside a Linux kernel
- Loadable kernel modules: allow privileged users to dynamically add/remove modules to the kernel
- Built-in packet filters

#pagebreak()

*How do you build a stateful firewall?*

#pagebreak()

`nf_conntrack` is a connection tracking framework in the Linux kernel built on top of netfilter, able to store context in memory.

Each packet will be marked as one of:
- NEW: connection is starting & the packet is part of a valid sequence. Only exists for a connection if the firewall has only seen traffic in one direction
- ESTABLISHED: connection has been established & is two-way
- RELATED: special state that helps to establish relationships among different connections
- INVALID: packet doesn’t follow the expected behaviour of a connection

#pagebreak()

*How do you build a application/proxy firewall? What is a key challenge in doing this and what are potential solutions?*

#pagebreak()

Typical implementation is a proxy.

Critical challenge is ensuring all web traffic goes through the proxy server

Solutions:
- Configure each host to redirect all web traffic to the proxy
- Place web proxies on a network bridge that connects internal & external networks

#pagebreak()

*What are other applications of a web proxy?*

#pagebreak()

Anonymising proxy: hide the origin of a network request from servers

Evade egress filtering

#pagebreak()

*Describe the Static Port Forwarding/SSH Tunnelling technique for firewall evasion.*

#pagebreak()

- 2 devices, home & inner, want to communicate but there's a firewall that blocks access between the two, but not between home and a secret 3rd machine called outer.

- Set up a tunnel between home and outer
- On the home end, the tunnel receives TCP packets from the telnet client
- Forwards TCP data to outer, which places the data in another TCP packet set for inner, which will be invisible to the firewall

#pagebreak()

*Describe the Dynamic Port Forwarding technique for firewall evasion. What is the advantage of this method over static port forwarding?*

#pagebreak()

Set up an ssh tunnel between a localhost port and the home machine

Redirect all web requests to go through this port

Set up a SOCKS proxy on the localhost: ssh will send the TCP data over the tunnel to the home machine, which will communicate with the blocked site.

Advantage: static has to be done on a per-website basis

#pagebreak()

*Describe the Reverse SSH Tunnelling technique for firewall evasion.*

#pagebreak()

A firewall may block incoming ssh sessions. Assuming it doesn't block outgoing ssh sessions, reverse ssh tunnelling can be used to access an internal website.

#pagebreak()

*Describe the VPN technique for firewall evasion.*

#pagebreak()

Create a tunnel between a computer inside the network & another one outside

IP packets sent via this tunnel

Tunnel traffic is encrypted, so firewalls can't see what is inside & can't filter.

#pagebreak()

*Describe the two methods for IP Tunnelling.*

#pagebreak()

IPSec Tunnelling
- Utilises the Internet Protocol Security proticol
- Has a tunneling mode, where the original IP packet is encapsualted and placed into a new packet.

TLS/SSL Tunneling
- Tunneling done outside the kernel (application level)
- Put each VPN-bound packet inside a TCP/UDP packet
- The other end of the tunnel will extract the IP packet
- To secure the packets, both ends will se TLS/SSL protocol on top of TCP/UDP

#pagebreak()

*Outline the DNS Hierarchy.*

#pagebreak()

#image("dns-hierarchy.png")

#pagebreak()

*What is the difference between Zone and Domain?*

#pagebreak()

A zone only contains a portion of the DNS data for a domain.

When a domain is divided into subdomains, their DNS data can still be put in the same zone (but don't have to be).

#pagebreak()

*What are Authoritative Name Servers?*

#pagebreak()

Publishes information about the zone.

Provides the original and definitive answers to DNS queries.

Can be either a master server, or a slave server.

Master server stores the master copied of all zone records whereas a slave server uses an automatic updating mechanismto maintain an identical copy of the master records.

There is a Many-to-Many relationships between zones and authoritative name servers.

#pagebreak()

*What are the 5 different types of TLDs?*

#pagebreak()

- Infrastructure: .arpa
- Generic: .com .net
- Sponsored: .edu .gov
- Country Code: .au .fr .de
- Reserved TLD: .example .test .local

#pagebreak()

*How does SNS lookup work?*

#pagebreak()

1. Query root server
  - Gives a set of servers to query instead
2. Query given servers
  - Given more servers
3. Repeat step 2, until we get given IP address

#pagebreak()

*What is the structure of a DNS response?*

#pagebreak()

- Question Section: Describes the question asked
- Answer Section: Records the answer to the question
- Authority Section: Records that point toward authoritative nameservers
- Additional Section: Records that are related to the query, e.g. nameserver IPs

#pagebreak()

*What are the 2 main DNS attacks?*

#pagebreak()

- DoS
- DNS Spoofing Attacks

#pagebreak()

*How can DNS attacks be performed on Compromised machines?*

#pagebreak()

Can alter the /hosts file or change the default DNS in the resolv.conf file.

#pagebreak()

*Explain Local DNS Cache Poisoning Attack?*

#pagebreak()

Attacker intercepts a DNS query, and responds to the query pretending to be the Local DNS server.

#pagebreak()

*Explain challenges with remote DNS Cache Poisoning Attack?*

#pagebreak()

Spoofing replies is much more difficult, because they need to guess 2 random numbers used by the query packet:
- source port number
- Transaction ID

#pagebreak()

*Explain how the Kaminsky Attack works.*

#pagebreak()

#image("kaminsky.png")

#pagebreak()

*Attacks from malicious DNS Server.*

#pagebreak()
In addition to providing an IP address in the answer section of the response, DNS server can also provide information in the authority and additional sections. Attackers can use these sections to provide fraudulent information.

#pagebreak()

*Why can't we simply reply with fake IPs of other domains? How do we get around this?*

#pagebreak()

DNS protocol makes it invalid to reply with IPs of different domains to the one requested. So will get ignored.

Instead, we can have our DNS Server reply with a fake hostname during reverse DNS lookups. So when a user queries our bad website IP address, we will tell them it is www.facebook.com.

#pagebreak()

*What is a DNS rebinding attack?*

#pagebreak()

Allows us to bypass same origin policy enforced by browsers.

#image("dns-rebinding.png")

#pagebreak()

*How to protect against DNS Cache Poisoning Attacks?*

#pagebreak()

- Domain Name System Security Extensions (DNSSEC)
  - All answers from DNSSEC protected zones are digitally signed.
  - Can check the signatures to see if the response is authentic or not.

#pagebreak()

*3 methods of DoS attacks on DNS servers*

#pagebreak()

1. Root Server attack
  - Bring down root servers
  - Hard as they are highly distributed and most responses from TLDs are cached for 48 hours.
  - Would need to bring down many machines for a long time to see any effect.
2. TLD Server attack
  - Usually easier, although TLDs such as gov, com, net have very resillient infrastructure. But some country TLDs are easier to attack.
3. Particular domain attack
  - target specific DNS service providers that offer services to domains you want to attack.
  - Spam requests.

#pagebreak()

*Explain Merkle Puzzles*

#pagebreak()

Problems that can be solved with some effort e.g. symmetric cipher with 32-bit k.

Alice: Prepares $2^32$ puzzles and sends them all to Bob

Bob: Chooses one of the puzzles, and solves it to obtain $(x_j, m_j)$ and sends $x_j$ to Alice.

Alice: Looks up puzzle with number $x_j$. Uses $m_j$ as the shared key.

Alice work: n

Bob Work: n

Eavesdropper work: $n^2$

#pagebreak()

*What is a primitve root modulo p*

#pagebreak()

A number whose powers generate all the nonzero numbers mod p.

e.g. P=7, $Z_7^{star} = {1,2,3,4,5,6}$

$5^1 = 5 mod 7$

$5^2 = 4 mod 7$

$5^3 = 6 mod 7$

$5^4 = 2 mod 7$

$5^5 = 3 mod 7$

$5^6 = 1 mod 7$

Thus, 5 is a primitive root modulo 7.

#pagebreak()

*What is a discrete logarithm?*

#pagebreak()

Given a value $h in Z_p^{star}$ with generator g,

find x s.t.

$
g^x = h (mod p)
$

#pagebreak()

*How does Diffie-Hellman key exchange work?*

#pagebreak()

Let p be a prime, and g a primitive root modulo p

Alice: selects x from [1,p-1] and calculate $A=g^x$

Bob: selects y from [1,p-1] and calculate $B=g^y$

send between

Alice: Compute $K=H(B^x)=H(g^(x y))$

Bob: Compute $K' = H(A^y) = H(g^(x y))$

#pagebreak()

*How hard is the Diffie-Hellman function?*

#pagebreak()

Best known algorithm run time is $e^O(n^(1/3))$

#pagebreak()

*What is the man-in-the-middle attack on DH?*

#pagebreak()

An attacker intercepts Alice's message, and creates their own $x in [1,p-1]$

Establishes a DH connection with Bob.

Also establishes the DH connection with Alice.

Now is in the middle of the communication, listening to everything.

#pagebreak()

*How to prevent man-in-the-middle attack on DH?*

#pagebreak()

Add authentication! This is hard, and is an active area of research.

some types include:
1. Public key certificates
  - SSL/TLS
2. Password based

#pagebreak()

*What is information leakage?*

#pagebreak()

Eve captures A,b. She can narrow down the password range, using a dictionary attack.

This is quite easy with DH, as if the decrypted result ends up in the range [p, 2^2048], the candidate is ruled out. Repeat until we find a value within [0,p-1].

#pagebreak()

*How does Public Key Encryption work?*

#pagebreak()

3 algorithms: G, E, D

G(): randomised alg to generate a key pair (pk, sk)

E(pk, m): randomised alg. that takes $m in M$ and outputs $c in C$

D(sk, c): decryption alg that takes $c in C$ and outputs $m in M$ or $tack.t$

Consistency: $forall ("pk", "sk") "output by" G: forall m in M D("sk", E("pk", m))=m$

#pagebreak()

*How does RSA work?*

#pagebreak()

Given 2 primes p and q, calculatinng $n=p times q$ is easy.

But factorising n is hard.

#pagebreak()

*Fermat's little theorem?*

#pagebreak()

For any prime p not dividin a, we have

$
a^(p-1) = 1 mod p
$

Proof:
- Given the set {1,2,...,p-1} we multiply it by a.
- The 2nd set has (p-1) distinct elements in [1,p-1], hence it's a permutation of the first set. Multiplying all elements in each set, we get: $(p-1)! = (p-1)!a^(p-1) mod p$
- Therefore, $1=a^(p-1) mod p$.

#pagebreak()

*Euler's theorem?*

#pagebreak()

- Euler's phi function: $Phi(n)$ is the number of positive integers less than n with which it has no divisor in common.
  - e.g. $Phi(n) = (p-1)(q-1)$ if $n=p q$
- Euler's theorem for any modulus n and any integer a, coprime to n, we have:
  - $a^(Phi(n))=1 mod n$

#pagebreak()

*Extended Euclidean Algorithm?*

#pagebreak()

#image("eea.png")

#pagebreak()

*Utilising the Extended Euclidean algorithm, how can we calculate the inverse of an element??*

#pagebreak()

Given $a in Z_N$ and a is relatively prime to N, we can compute its inverse by substituting a and N into the Extended Euclidean Algorithm.

$s times a plus t times N = "GCD"(a, N) = 1$

We have $s times a = 1 mod N => a^(-1) = s$

#pagebreak()

*How does RSA work - in detail?*

#pagebreak()

Generate 2 large n-bit distinct primes p and q

compute $N = p dot q$ and $phi(N) = (p-1) dot (q-1)$

Choose a random integer e s.t. $"gcd"(e, phi(N)) = 1$

Compute e's inverse d: $d dot e = 1 mod phi(N)$

Output: $"pk" = (N,e), "sk"=(N,d)$

Encrpytion: $c = m^e mod N$

Decryption: $m = c^d mod N$

#pagebreak()

*Prove correctness of RSA?*

#pagebreak()

case 1: If m is relatively primte to N, i.e.e, $m in Z_N^{star}$
  - $c^d = (m^e)^d = m^(d e) = m^(d e mod phi(N)) = m mod N$
case 2: Else
  - $c_d = (m^e)^d = m^(d e) = m^(d e mod (p-1)) = m mod p$
  - $c_d = (m^e)^d = m^(d e) = m^(d e mod (q-1)) = m mod q$
  - Hence $c^d = m mod p times q = m mod N$

#pagebreak()

*Meet in the middle attack on textbook RSA*

#pagebreak()

#image("meet-in-middle.png")

#pagebreak()

*Mangling ciphertexts on textbook RSA*

#pagebreak()

#image("mangling.png")

#pagebreak()

*What's the general idea behind digital signatures?*

#pagebreak()

Sign information by encrypting with your secret key. Given RSA is secure, people can guarantee data comes from me, if upon decrypting the data with my public key, you get the correct data.

#pagebreak()

*What's a no message attack?*

#pagebreak()

#image("no-msg.png")

#pagebreak()

*What's a selected message attack?*

#pagebreak()

1. A chooses target message m.
2. A chooses a random message $m_1$.
3. Sets $m_2 = m/m_1 mod N$
4. A requests signatures $sigma_1$ and $sigma_2$ on $m_1$ and $m_2$.
5. Result $sigma = sigma_1 dot sigma_2 mod N$ is a valid signature on m.

#pagebreak()

*Tamper Evident vs Tamper Resistance*

#pagebreak()

Tamper Evident: detectable upon tampeer

Tamper resistant: robust against tamper

#pagebreak()

*What is a Hardware Security Module?*

#pagebreak()

A closed system to provide the following functions:
- Onboard secure generation
- Onboard secure storage
- Use of cryptographic and sensitive data
- Offloading application servers for crypto operations

It erases all data upon detecting tampering.

#pagebreak()

*What is a Master key attack on HSM?*

#pagebreak()

Keys are often left on Programmable ROM devices. They can easily be read! Custodians used to hand keys to engineers to work on. This would give an attacker a window to read the master key.

#pagebreak()

*What is a Casing attack on HSM?*

#pagebreak()

Simply cut into the device to access the hardware. Could take the hardware and perform analysis on it.

#pagebreak()

*What is a Epxoy attack on HSM?*

#pagebreak()

Can scrape away at the epoxy

Once have access to bus, can probe the bus lines as they are usually unencrypted.

#pagebreak()

*What is a Frozen memory attack on HSM?*

#pagebreak()

When in low temperature, traces of data will be retained on hardware, even if it has been "deleted".

Attakers could freeze the machine before attempting to break into it.

#pagebreak()

*What is a Side channel attack on HSM?*

#pagebreak()

Monitor the RF, power, timing to deduce secret keys.

#pagebreak()

*What side channel information is available?*

#pagebreak()

- Power consumption
- Electromagnetic radiation
- Timings
- Errors

Can analyse
- Power variation using Simple Power Analysis, or Differential Power Analysis.

#pagebreak()

*Desribe the Smart card Hardware*

#pagebreak()

- Has 8 contact points
- Central Processing Unit
  - 8 bit microcontroller
  - 5 MHz clock
- Cryptographic coprocessor
  - Expediting modular calculations
- Memory System
  - ROM
  - EEPROM - persistant storage - Fast reading, slow writing
  - RAM

#pagebreak()

*Desribe the Smart card communcation pattern*

#pagebreak()

- Master-slave model
- A smart card always plays the passive slave

#pagebreak()

*What is the Cambridge No-PIN attack?*

#pagebreak()

#image("no-pin.png")

#pagebreak()

*What is a security API?*

#pagebreak()

An application programming interface that uses cryptography to enforce a security policy on the interactions between 2 entities.

#pagebreak()

*What are the aims of HSM?*

#pagebreak()

- Isolate the defined code which is security relevant and to physically separate it into a device not under control of the system adminsitrator
- To minimise the amount of security relevant code and to keep the rules governing its use as simple as possible, so that it would be easier to avoid bugs.

#pagebreak()

*What is the unknown pin attack?*

#pagebreak()

The magnetic stripe on a card contains your account number and your pin. It is encrypted and only an ATM can read the message. However, you can copy your PIN onto a different card. Then Your pin will work for that card.

#pagebreak()

*What is the PIN offset attack?*

#pagebreak()

#image("pin-offset.png")

#pagebreak()

*What is the decimilisation table attack?*

#pagebreak()

- need to convert hex to decimal to create a PIN
- Decimilisation table is not fixed
- An insider attacker can exploit this flaw to find out any banks customer's PIN in 15 attempts rather than 10000.
- Can use a dummy decimilsation table e.g. 0100000000000000
  - A trial PIN of 0000 will confirm the default PIN doesn't contain the number 1.

#pagebreak()

*What is the XOR-To-Null attack?*

#pagebreak()

You are an engineer and have access to a VSM (Visa Security Module). The goal of the VSM is to allow multiple "admins" to provide keys to ensure customers pins are secure.

You can use the VSM API to send 2 of the same key, that when XORd gives 0.

Can now pass in an encrypted PIN verification key, and it will return the PIN encrypted with key 0.

#pagebreak()

*What is the Meet-in-the-Middle attack in API Security?*

#pagebreak()

An insider attacker just needs to break 1 key of a VSM, and can then use HSM API to crack others.

He can generate $2^16$ keys using the HSM, go home and exhaustively search through the keys calculating check values, until we find a match.

This should take around a week!